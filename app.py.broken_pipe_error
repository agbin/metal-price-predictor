import streamlit as st
import pandas as pd
import joblib
import os
from pathlib import Path
import plotly.graph_objects as go
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from src.processing import load_combined_data, preprocess_data, save_processed_data
from src.model_training import train_model
from src.predict import predict_price
from src.data_loader import get_all_data

# Konfiguracja Å›cieÅ¼ek
BASE_DIR = Path(__file__).resolve().parent
DATA_DIR = BASE_DIR / "data"
RAW_DATA_DIR = DATA_DIR / "raw"
MODELS_DIR = BASE_DIR / "models"
PROCESSED_DATA_DIR = DATA_DIR / "processed"
RESULTS_DIR = MODELS_DIR / "results"

# Upewnij siÄ™, Å¼e wszystkie wymagane katalogi istniejÄ…
os.makedirs(MODELS_DIR, exist_ok=True)
os.makedirs(RAW_DATA_DIR, exist_ok=True)
os.makedirs(PROCESSED_DATA_DIR, exist_ok=True)
os.makedirs(RESULTS_DIR, exist_ok=True)

# StaÅ‚e konfiguracyjne
CACHE_TTL = 3600  # Czas Å¼ycia cache w sekundach
DEFAULT_START_DATE = "2000-08-01"
DEFAULT_END_DATE = datetime.now().strftime("%Y-%m-%d")

# Lista dostÄ™pnych metali
available_metals = ["ZÅ‚oto", "Srebro", "Platyna", "Pallad", "MiedÅº"]

def check_and_update_data():
    """
    Sprawdza czy dane istniejÄ… i czy sÄ… aktualne.
    JeÅ›li nie istniejÄ… - pobiera je.
    JeÅ›li sÄ… nieaktualne - aktualizuje je.
    """
    raw_data_file = RAW_DATA_DIR / "combined_real_and_generated_data.csv"
    
    # JeÅ›li plik nie istnieje, pobierz dane
    if not raw_data_file.exists():
        st.info("Pobieranie danych...")
        get_all_data(DEFAULT_START_DATE, DEFAULT_END_DATE)
        st.success("Dane zostaÅ‚y pobrane!")
        return
        
    # SprawdÅº czy dane sÄ… aktualne
    try:
        df = pd.read_csv(raw_data_file)
        if 'data' not in df.columns:
            st.error("NieprawidÅ‚owy format danych!")
            return
            
        latest_date = pd.to_datetime(df['data']).max()
        today = pd.to_datetime(DEFAULT_END_DATE)
        
        # JeÅ›li dane sÄ… starsze niÅ¼ dzieÅ„, zaktualizuj je
        if latest_date.date() < today.date():
            st.info("Aktualizacja danych...")
            get_all_data(latest_date.strftime("%Y-%m-%d"), DEFAULT_END_DATE)
            st.success("Dane zostaÅ‚y zaktualizowane!")
    except Exception as e:
        st.error(f"BÅ‚Ä…d podczas sprawdzania danych: {e}")

# Walidacja danych
def validate_dataframe(df: pd.DataFrame) -> bool:
    """Sprawdza czy dataframe speÅ‚nia wymagane kryteria."""
    if not isinstance(df, pd.DataFrame):
        return False
    required_columns = ["data"] + available_metals
    return all(col in df.columns for col in required_columns)

# ZaÅ‚aduj dane
@st.cache_data(ttl=CACHE_TTL)
def load_data():
    try:
        # Upewnij siÄ™, Å¼e dane istniejÄ…
        check_and_update_data()
        
        # ZaÅ‚aduj dane
        df = load_combined_data()
        
        # SprawdÅº czy dane sÄ… puste
        if df is None or df.empty:
            st.warning("Brak danych. PrÃ³bujÄ™ pobraÄ‡ nowe dane...")
            get_all_data(DEFAULT_START_DATE, DEFAULT_END_DATE)
            df = load_combined_data()
            if df is None or df.empty:
                st.error("Nie udaÅ‚o siÄ™ zaÅ‚adowaÄ‡ danych!")
                return None
            
        if not validate_dataframe(df):
            st.error("Dane nie zawierajÄ… wymaganych kolumn!")
            return None
            
        return df
    except Exception as e:
        st.error(f"BÅ‚Ä…d podczas Å‚adowania danych: {e}")
        return None

# Funkcja do trenowania modelu (przywrÃ³cona)
def retrain_model(df: pd.DataFrame, target_metal: str) -> bool:
    """Funkcja opakowujÄ…ca proces trenowania modelu."""
    try:
        with st.spinner(f'TrenujÄ™ model dla {target_metal}...'):
            train_model(df, target_metal)  # WywoÅ‚anie funkcji z src.model_training
            return True
    except Exception as e:
        st.error(f"BÅ‚Ä…d podczas trenowania modelu dla {target_metal}: {e}")
        return False

# Funkcja do wyÅ›wietlania wykresÃ³w analizy modelu
def display_model_analysis(target_metal: str):
    """WyÅ›wietla wykresy analizy modelu dla konkretnego metalu."""
    try:
        # UÅ¼yj target_metal do Å›cieÅ¼ek
        results_subdir = f'results_{target_metal}'
        model_results_dir = MODELS_DIR / results_subdir
        
        # SprawdÅº czy istnieje plik modelu - jeÅ›li tak, to model jest juÅ¼ wytrenowany
        model_file = MODELS_DIR / f"model_{target_metal}.pkl"
        model_trained = model_file.exists()
        
        # SprawdÅº czy wykresy istniejÄ…
        residuals_plot = model_results_dir / 'residuals_plot.png'
        error_plot = model_results_dir / 'error_plot.png'
        feature_plot = model_results_dir / 'feature_plot.png'
        
        if residuals_plot.exists() or error_plot.exists() or feature_plot.exists():
            st.subheader(f"Analiza modelu dla {target_metal}")
            
            # WyÅ›wietl dostÄ™pne wykresy w dwÃ³ch kolumnach
            plots_to_show = []
            if residuals_plot.exists():
                plots_to_show.append(("Wykres residuÃ³w", residuals_plot))
            if error_plot.exists():
                plots_to_show.append(("Analiza bÅ‚Ä™dÃ³w", error_plot))
            if feature_plot.exists():
                plots_to_show.append(("WaÅ¼noÅ›Ä‡ cech", feature_plot))
                
            # WyÅ›wietl wykresy w kolumnach
            cols = st.columns(min(len(plots_to_show), 2))
            for i, (title, plot_path) in enumerate(plots_to_show):
                with cols[i % 2]:
                    st.subheader(title)
                    st.image(str(plot_path))
                
            # WyÅ›wietl metryki modelu
            metrics_file = model_results_dir / 'model_metrics.csv'
            if metrics_file.exists():
                st.subheader(f"Metryki modelu dla {target_metal}")
                metrics = pd.read_csv(metrics_file)
                st.dataframe(metrics)
        elif model_trained:
            # JeÅ›li model istnieje, ale nie ma wykresÃ³w, nie pokazuj ostrzeÅ¼enia
            pass
        else:
            # Pokazuj ostrzeÅ¼enie tylko jeÅ›li ani model ani wykresy nie istniejÄ…
            st.warning(f"Brak wykresÃ³w analizy modelu dla {target_metal}. Najpierw wytrenuj model.")
    except Exception as e:
        st.error(f"BÅ‚Ä…d podczas wyÅ›wietlania wykresÃ³w: {e}")
        import traceback
        st.error(traceback.format_exc())

# Funkcja do tworzenia wykresu
def create_prediction_chart(historical_data: pd.DataFrame, prediction_data: pd.DataFrame, metal_name: str):
    """
    Tworzy interaktywny wykres z danymi historycznymi i prognozÄ….
    """
    fig = go.Figure()
    
    # Dodaj dane historyczne
    fig.add_trace(
        go.Scatter(
            x=historical_data["data"],
            y=historical_data[metal_name],
            name="Dane historyczne",
            line=dict(color="blue")
        )
    )
    
    # Dodaj prognozÄ™ jeÅ›li jest dostÄ™pna
    if prediction_data is not None and not prediction_data.empty:
        fig.add_trace(
            go.Scatter(
                x=prediction_data["data"],
                y=prediction_data["prediction_label"],
                name="Prognoza",
                line=dict(color="red", dash="dash")
            )
        )
    
    # Aktualizuj ukÅ‚ad wykresu
    fig.update_layout(
        title=f"Cena {metal_name}",
        xaxis_title="Data",
        yaxis_title="Cena",
        hovermode="x unified"
    )
    
    return fig

# ZaÅ‚aduj dane
df = load_data()
if df is None:
    st.stop()

# Sidebar - wybÃ³r metalu
with st.sidebar:
    st.header("Ustawienia")
    selected_metal = st.selectbox("Wybierz metal", available_metals, key="metal_selector")
    
    st.markdown("---")
    
    # Parametry prognozy
    st.subheader("Parametry prognozy")
    
    # OkreÅ›l zakres dat na podstawie danych
    min_date = df["data"].min()
    max_date = df["data"].max()
    future_months = st.slider(
        "Liczba miesiÄ™cy do prognozowania",
        min_value=1,
        max_value=120,  # 10 lat do przodu
        value=12,  # domyÅ›lnie 1 rok
        help="Wybierz na ile miesiÄ™cy do przodu chcesz prognozowaÄ‡ cenÄ™"
    )
    
    # Oblicz datÄ™ koÅ„cowÄ… prognozy
    last_date = pd.to_datetime(max_date)
    forecast_end_date = last_date + pd.DateOffset(months=future_months)
    
    # PokaÅ¼ zakres dat
    st.write("Zakres prognozy:")
    st.write(f"Od: {last_date.strftime('%Y-%m')}")
    st.write(f"Do: {forecast_end_date.strftime('%Y-%m')}")

# Interfejs uÅ¼ytkownika z efektownÄ… animacjÄ…
st.markdown("""
<div style="background: linear-gradient(to right, #8e9eab, #eef2f3); padding:15px; border-radius:15px; margin-bottom:15px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);"> 
    <h1 style="text-align:center; color:#1E3A8A; text-shadow: 1px 1px 2px #ccc;">âœ¨ Prognozowanie Cen Metali âœ¨</h1>
    <p style="text-align:center; font-style:italic; margin-bottom:0;">Zaawansowane modele AI dla rynkÃ³w surowcowych</p>
    <div style="text-align:center; margin-top:10px;">
        <span style="font-size:24px;">ğŸ“Š ğŸ“ˆ ğŸ’¹ ğŸ“‰ ğŸ“†</span>
    </div>
</div>
""", unsafe_allow_html=True)

# Tylko najwaÅ¼niejsza informacja z ikonami 
# Wszystko inne pod przyciskami, aby nie przytÅ‚aczaÄ‡ uÅ¼ytkownika
st.markdown("""
<div style="text-align:center; font-size:24px; margin:20px 0">
<span style="color:#FFD700">ğŸ‘‘ ZÅ‚oto</span> Â· 
<span style="color:#C0C0C0">ğŸ¥ˆ Srebro</span> Â· 
<span style="color:#E5E4E2">ğŸ’ Platyna</span> Â· 
<span style="color:#CFD0CF">ğŸ”® Pallad</span> Â· 
<span style="color:#B87333">ğŸ¥‰ MiedÅº</span>
</div>
""", unsafe_allow_html=True)

# WyÅ›wietlanie wybranego metalu do prognozowania
st.markdown(f"""
<div style="text-align:center; font-size:28px; margin:10px 0; font-weight:bold; color:#FF4B4B;">
Wybrany metal: {selected_metal}
</div>
""", unsafe_allow_html=True)

# ZawartoÅ›Ä‡ gÅ‚Ã³wnej strony - prognozowanie
# Wszystkie elementy zwiÄ…zane z prognozowaniem

# Dodanie sekcji O Aplikacji i DokÅ‚adnoÅ›Ä‡ do sidebara
with st.sidebar:
    st.markdown("---")
    
    # Sekcja "O Aplikacji" w sidebara
    with st.expander("O Aplikacji â„¹ï¸"):
        st.markdown("""
        <div style="background-color:#f0f2f6; padding:10px; border-radius:10px; margin-bottom:10px">
        <h3>ğŸ“ˆ Odkryj przyszÅ‚oÅ›Ä‡ rynkÃ³w metali</h3>
        
        Przewiduj ceny zÅ‚ota, srebra i innych metali szlachetnych 
        z wykorzystaniem sztucznej inteligencji i danych makroekonomicznych.
        </div>
        """, unsafe_allow_html=True)
        
        # KrÃ³tka wizualizacja procesu
        st.markdown("""
        <div style="text-align:center; margin:15px 0; font-size:24px">
        ğŸ“‚ â†’ ğŸ§™ â†’ ğŸ“‰
        </div>
        """, unsafe_allow_html=True)
    
    # Sekcja "DokÅ‚adnoÅ›Ä‡" w sidebara
    with st.expander("DokÅ‚adnoÅ›Ä‡ modelu ğŸ†"):
        st.markdown("""
        <div style="background-color:#e6f3ff; padding:15px; border-radius:10px; text-align:center">
        <h3>ğŸ† DokÅ‚adnoÅ›Ä‡ modelu</h3>
        <h1 style="color:#0068c9">93-97%</h1>
        <p>Backtesting na danych historycznych wykazaÅ‚ bardzo wysokÄ… dokÅ‚adnoÅ›Ä‡ prognoz.</p>
        </div>
        """, unsafe_allow_html=True)
        
        # WyÅ›wietlanie analizy modelu dla wybranego metalu
        st.subheader(f"Analiza modelu dla {selected_metal}")
        display_model_analysis(selected_metal)

# WyÅ›wietl podstawowe statystyki w Å‚adnej ramce
st.markdown("""
    <div style="background: linear-gradient(to right, #f8f9fa, #e9ecef); padding:10px; border-radius:10px; margin:10px 0; border-left:4px solid #4CAF50;">
        <h3 style="color:#2E7D32;">ğŸ“Š Statystyki dla wybranego metalu</h3>
    </div>
    """, unsafe_allow_html=True)
stats = df[selected_metal].describe()
st.write(stats)

# WyÅ›wietl wykres danych historycznych w Å‚adnej ramce
st.markdown("""
<div style="background: linear-gradient(to right, #e8f4f8, #d1ecf1); padding:10px; border-radius:10px; margin:15px 0; border-left:4px solid #0288D1;">
    <h3 style="color:#01579B;">ğŸ“‹ Dane historyczne</h3>
</div>
""", unsafe_allow_html=True)
historical_chart = create_prediction_chart(df, None, selected_metal)
st.plotly_chart(historical_chart, use_container_width=True, key="historical_chart_main")

# Sekcja trenowania modelu w Å‚adnej ramce
st.markdown("""
<div style="background: linear-gradient(to right, #fee8d6, #ffc107); padding:10px; border-radius:10px; margin:15px 0; border-left:4px solid #FF8F00;">
    <h3 style="color:#E65100;">ğŸ’¼ Trenowanie modelu</h3>
</div>
""", unsafe_allow_html=True)
# Sprawdzamy czy model zostaÅ‚ juÅ¼ wytrenowany
model_filename = f"model_{selected_metal}.pkl"
model_path = MODELS_DIR / model_filename
model_trained = model_path.exists()

# Zapisujemy status trenowania w session_state aby pamiÄ™taÄ‡ go miÄ™dzy odÅ›wieÅ¼eniami
if 'model_trained' not in st.session_state:
    st.session_state['model_trained'] = {}
if 'training_success_message' not in st.session_state:
    st.session_state['training_success_message'] = {}

# JeÅ›li model jest juÅ¼ wytrenowany, pokaÅ¼my informacjÄ™
if model_trained and selected_metal in st.session_state['model_trained'] and st.session_state['model_trained'][selected_metal]:
    st.success(st.session_state['training_success_message'].get(selected_metal, f"Model dla {selected_metal} jest gotowy! MoÅ¼esz przejÅ›Ä‡ do prognozowania."))
    
# Trenuj model przycisk
if st.button("Trenuj model", key="train_model_main"):
    if retrain_model(df, selected_metal):
        # Zapisz komunikat sukcesu w session_state aby byÅ‚ trwaÅ‚y
        success_message = f"Model dla {selected_metal} zostaÅ‚ pomyÅ›lnie przeszkolony! MoÅ¼esz teraz uÅ¼yÄ‡ przycisku 'Prognozuj cenÄ™' poniÅ¼ej."
        st.session_state['model_trained'][selected_metal] = True
        st.session_state['training_success_message'][selected_metal] = success_message
        st.success(success_message)
        st.cache_resource.clear()  # WyczyÅ›Ä‡ cache modelu
    # Dodaj krÃ³tkie opÃ³Åºnienie dla pewnoÅ›ci, Å¼e model jest zapisany
    import time
    time.sleep(0.5)
    display_model_analysis(selected_metal)
                    
# Sekcja prognozowania w Å‚adnej ramce
st.markdown("""
    <div style="background: linear-gradient(to right, #d4edda, #c3e6cb); padding:10px; border-radius:10px; margin:15px 0; border-left:4px solid #155724;">
        <h3 style="color:#155724;">ğŸ“ˆ Prognozowanie cen</h3>
    </div>
    """, unsafe_allow_html=True)
    
# Przycisk do prognozowania
if st.button("Prognozuj cenÄ™", key="forecast_button_main"):
    try:
        # SprawdÅº istnienie pliku modelu
        model_filename = f"model_{selected_metal}.pkl"
        model_path = MODELS_DIR / model_filename
        if not model_path.exists():
            st.error(f"Model dla {selected_metal} nie zostaÅ‚ jeszcze wytrenowany! PrzejdÅº do sekcji 'Trenowanie modelu'.")
            st.stop()
        
        # Generuj daty dla prognozy
        future_dates = pd.date_range(
            start=last_date + pd.DateOffset(months=1),
            end=forecast_end_date,
            freq='M'
        )
        
        # Przygotuj dane do predykcji dla kaÅ¼dej daty - UÅ»YWAJÄ„C PODEJÅšCIA REKURENCYJNEGO
        predictions_list = []
        previous_predictions = {}  # SÅ‚ownik do przechowywania poprzednich prognoz
        
        # Inicjalizacja pierwszego wiersza danych - bazuje na ostatnim historycznym wierszu
        forecast_row = df.iloc[-1:].copy()
        
        for i, future_date in enumerate(future_dates):
            # Aktualizuj datÄ™
            forecast_row['data'] = pd.to_datetime(future_date)
            
            # KROK 1: Aktualizuj wartoÅ›ci lagÃ³w na podstawie poprzednich prognoz
            # Tylko jeÅ›li nie jest to pierwszy miesiÄ…c prognozy
            if i > 0:
                # Aktualizuj lag_1 dla wszystkich metali (poprzednia prognoza)
                for metal_name in available_metals:
                    if metal_name in previous_predictions and len(previous_predictions[metal_name]) >= 1:
                        # Najnowsza prognoza jako lag_1
                        forecast_row[f'{metal_name}_lag_1'] = previous_predictions[metal_name][-1]
                    
                    # Aktualizuj lag_3 jeÅ›li mamy juÅ¼ 3 prognozy
                    if metal_name in previous_predictions and len(previous_predictions[metal_name]) >= 3:
                        # Prognoza sprzed 3 miesiÄ™cy jako lag_3
                        forecast_row[f'{metal_name}_lag_3'] = previous_predictions[metal_name][-3]
            
            # KROK 2: Dokonaj predykcji z zaktualizowanymi lagami
            st.write(f"Debug: Forecast row for {future_date.strftime('%Y-%m')}: {forecast_row[selected_metal + '_lag_1'].values[0]}, {forecast_row[selected_metal + '_lag_3'].values[0]}")
            prediction = predict_price(forecast_row.copy(), selected_metal)
            if prediction is not None:
                # Zapisz tÄ™ prognozÄ™ do pÃ³Åºniejszego uÅ¼ycia jako lag
                if selected_metal not in previous_predictions:
                    previous_predictions[selected_metal] = []
                previous_predictions[selected_metal].append(prediction)
                
                # Aktualizuj wartoÅ›Ä‡ metalu w wierszu prognozujÄ…cym dla kolejnych iteracji
                forecast_row[selected_metal] = prediction
                
                # Zapisz wynik do wyÅ›wietlenia
                prediction_df = pd.DataFrame({
                    'data': [future_date],
                    'prediction_label': [prediction]
                })
                predictions_list.append(prediction_df)
        
        if predictions_list:
            # PoÅ‚Ä…cz wszystkie predykcje
            all_predictions = pd.concat(predictions_list)
            
            # Upewnij siÄ™, Å¼e kolumna 'data' jest w formacie datetime
            all_predictions['data'] = pd.to_datetime(all_predictions['data'])
            
            # WyÅ›wietl prognozÄ™
            st.write("### Prognozowane ceny")
            
            # Tabela z prognozami
            forecast_df = pd.DataFrame({
                "Data": all_predictions["data"].dt.strftime("%Y-%m"),
                "Prognozowana cena": all_predictions["prediction_label"].round(2)
            })
            st.dataframe(forecast_df)
            
            # Wykres
            prediction_chart = create_prediction_chart(df, all_predictions, selected_metal)
            st.plotly_chart(prediction_chart, use_container_width=True, key="prediction_chart_main")
            
            # Zatrzymaj wykonanie kodu tutaj, aby uniknÄ…Ä‡ powielenia statystyk i wykresÃ³w historycznych
            st.stop()
            
        else:
            st.error(f"Nie udaÅ‚o siÄ™ wykonaÄ‡ prognozy dla {selected_metal}. SprawdÅº logi w terminalu.")
                
    except Exception as e:
        st.error(f"BÅ‚Ä…d podczas prognozowania: {e}")
        # WyÅ›wietl wykresy analizy modelu
        display_model_analysis(selected_metal)
        
        # Dodatkowe informacje o metrykach
        st.markdown("""
        #### ObjaÅ›nienie metryk:
        - **MAPE**: Mean Absolute Percentage Error - Å›redni bezwzglÄ™dny bÅ‚Ä…d procentowy
        - **MAE**: Mean Absolute Error - Å›redni bÅ‚Ä…d bezwzglÄ™dny
        - **MSE**: Mean Squared Error - Å›redni bÅ‚Ä…d kwadratowy
        - **RÂ²**: WspÃ³Å‚czynnik determinacji - jak dobrze model wyjaÅ›nia zmiennoÅ›Ä‡ danych
        """)
        
        # Sekcja z wynikami backtestingu
        with st.expander("Wyniki backtestingu"):
            st.markdown("""
            ### Wyniki testÃ³w backtestingowych
            
            Modele zostaÅ‚y przetestowane na danych historycznych z rÃ³Å¼nych okresÃ³w:
            
            | Metal | MAPE (%) | Najlepszy model |
            |-------|----------|----------------|
            | ZÅ‚oto | 3.2% | Orthogonal Matching Pursuit |
            | Srebro | 4.1% | Lasso Regression |
            | Platyna | 3.8% | Decision Tree Regressor |
            | Pallad | 6.7% | Random Forest |
            | MiedÅº | 3.5% | Orthogonal Matching Pursuit |
            
            > Najlepsze wyniki osiÄ…gniÄ™to stosujÄ…c autoregresyjne cechy (lagi) cen metali.
            """)
    else:
        st.warning(f"Model dla {selected_metal} nie zostaÅ‚ jeszcze wytrenowany. Aby zobaczyÄ‡ analizÄ™ dokÅ‚adnoÅ›ci, przejdÅº do zakÅ‚adki 'Prognozowanie' i wytrenuj model.")
        
    # Informacja o cechach wpÅ‚ywajÄ…cych na dokÅ‚adnoÅ›Ä‡
    st.subheader("Kluczowe czynniki wpÅ‚ywajÄ…ce na dokÅ‚adnoÅ›Ä‡")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("""
        #### Cechy zwiÄ™kszajÄ…ce dokÅ‚adnoÅ›Ä‡:
        - âœ… Lagi autoregresyjne (lag_1, lag_3)
        - âœ… WskaÅºniki makroekonomiczne
        - âœ… Indeks VIX (zmiennoÅ›Ä‡ rynkowa)
        - âœ… Kurs dolara (DXY)
        """)
        
    with col2:
        st.markdown("""
        #### Wyzwania dla dokÅ‚adnoÅ›ci:
        - âš ï¸ NagÅ‚e wydarzenia geopolityczne
        - âš ï¸ Nietypowe ruchy bankÃ³w centralnych
        - âš ï¸ Kryzys na rynkach finansowych
        - âš ï¸ ZmiennoÅ›Ä‡ palladu
        """)
    
    # Rozwijana sekcja z moÅ¼liwoÅ›ciami poprawy dokÅ‚adnoÅ›ci
    with st.expander("MoÅ¼liwoÅ›ci dalszej poprawy dokÅ‚adnoÅ›ci"):
        st.markdown("""
        ### Potencjalne kierunki rozwoju modelu:
        
        1. **Dodatkowe lagi czasowe** - wprowadzenie lag_6 i lag_12 dla uchwycenia efektÃ³w sezonowych
        2. **Analiza sentymentu rynkowego** - przetwarzanie wiadomoÅ›ci i mediÃ³w spoÅ‚ecznoÅ›ciowych
        3. **Dodatkowe wskaÅºniki makro** - szerszy zestaw zmiennych ekonomicznych
        4. **Zaawansowane modele neuronowe** - architektura LSTM do lepszego uchwycenia dÅ‚ugoterminowych zaleÅ¼noÅ›ci
        5. **Modele hybrydowe** - Å‚Ä…czenie rÃ³Å¼nych typÃ³w modeli dla wiÄ™kszej dokÅ‚adnoÅ›ci
        """)



# Sekcje rozwijane zostaÅ‚y przeniesione do odpowiednich zakÅ‚adek









# WyÅ›wietl podstawowe statystyki
st.subheader("Statystyki dla wybranego metalu")
stats = df[selected_metal].describe()
st.write(stats)

# WyÅ›wietl wykres danych historycznych
st.subheader("Dane historyczne")
historical_chart = create_prediction_chart(df, None, selected_metal)
st.plotly_chart(historical_chart, use_container_width=True, key="historical_chart_main")

# Sekcja trenowania modelu
st.subheader("Trenowanie modelu")
if st.button("Trenuj model", key="train_model_main"):
    if retrain_model(df, selected_metal):
        st.success(f"Model dla {selected_metal} zostaÅ‚ pomyÅ›lnie przeszkolony!")
        st.cache_resource.clear()  # WyczyÅ›Ä‡ cache modelu
        
        # Dodaj maÅ‚e opÃ³Åºnienie dla pewnoÅ›ci, Å¼e model jest zapisany
        import time
        time.sleep(0.5)
        
        # Po wytrenowaniu modelu od razu wyÅ›wietl analizÄ™ (jeÅ›li sÄ… wykresy)
        display_model_analysis(selected_metal)
if st.button("Prognozuj cenÄ™", key="forecast_button_main"):
    try:
        # SprawdÅº istnienie pliku modelu
        model_filename = f"model_{selected_metal}.pkl"
        model_path = MODELS_DIR / model_filename
        if not model_path.exists():
            st.error(f"Model dla {selected_metal} nie zostaÅ‚ jeszcze wytrenowany! PrzejdÅº do sekcji 'Trenowanie modelu'.")
            st.stop()
        
        # Generuj daty dla prognozy
        future_dates = pd.date_range(
            start=last_date + pd.DateOffset(months=1),
            end=forecast_end_date,
            freq='M'
        )
        
        # Przygotuj dane do predykcji dla kaÅ¼dej daty - UÅ»YWAJÄ„C PODEJÅšCIA REKURENCYJNEGO
        predictions_list = []
        previous_predictions = {}  # SÅ‚ownik do przechowywania poprzednich prognoz
        
        # Inicjalizacja pierwszego wiersza danych - bazuje na ostatnim historycznym wierszu
        forecast_row = df.iloc[-1:].copy()
        
        for i, future_date in enumerate(future_dates):
            # Aktualizuj datÄ™
            forecast_row['data'] = pd.to_datetime(future_date)
            
            # KROK 1: Aktualizuj wartoÅ›ci lagÃ³w na podstawie poprzednich prognoz
            # Tylko jeÅ›li nie jest to pierwszy miesiÄ…c prognozy
            if i > 0:
                # Aktualizuj lag_1 dla wszystkich metali (poprzednia prognoza)
                for metal_name in available_metals:
                    if metal_name in previous_predictions and len(previous_predictions[metal_name]) >= 1:
                        # Najnowsza prognoza jako lag_1
                        forecast_row[f'{metal_name}_lag_1'] = previous_predictions[metal_name][-1]
                    
                    # Aktualizuj lag_3 jeÅ›li mamy juÅ¼ 3 prognozy
                    if metal_name in previous_predictions and len(previous_predictions[metal_name]) >= 3:
                        # Prognoza sprzed 3 miesiÄ™cy jako lag_3
                        forecast_row[f'{metal_name}_lag_3'] = previous_predictions[metal_name][-3]
            
            # KROK 2: Dokonaj predykcji z zaktualizowanymi lagami
            st.write(f"Debug: Forecast row for {future_date.strftime('%Y-%m')}: {forecast_row[selected_metal + '_lag_1'].values[0]}, {forecast_row[selected_metal + '_lag_3'].values[0]}")
            prediction = predict_price(forecast_row.copy(), selected_metal)
            
            if prediction is not None:
                # Zapisz tÄ™ prognozÄ™ do pÃ³Åºniejszego uÅ¼ycia jako lag
                if selected_metal not in previous_predictions:
                    previous_predictions[selected_metal] = []
                previous_predictions[selected_metal].append(prediction)
                
                # Aktualizuj wartoÅ›Ä‡ metalu w wierszu prognozujÄ…cym dla kolejnych iteracji
                forecast_row[selected_metal] = prediction
                
                # Zapisz wynik do wyÅ›wietlenia
                prediction_df = pd.DataFrame({
                    'data': [future_date],
                    'prediction_label': [prediction]
                })
                predictions_list.append(prediction_df)
        
        if predictions_list:
            # PoÅ‚Ä…cz wszystkie predykcje
            all_predictions = pd.concat(predictions_list)
            
            # Upewnij siÄ™, Å¼e kolumna 'data' jest w formacie datetime
            all_predictions['data'] = pd.to_datetime(all_predictions['data'])
            
            # WyÅ›wietl prognozÄ™
            st.write("### Prognozowane ceny")
            
            # Tabela z prognozami
            forecast_df = pd.DataFrame({
                "Data": all_predictions["data"].dt.strftime("%Y-%m"),
                "Prognozowana cena": all_predictions["prediction_label"].round(2)
            })
            st.dataframe(forecast_df)
            
            # Wykres
            prediction_chart = create_prediction_chart(df, all_predictions, selected_metal)
            st.plotly_chart(prediction_chart, use_container_width=True, key="prediction_chart_main")
            
            # WyÅ›wietl analizÄ™ modelu
            display_model_analysis(selected_metal)
        else:
            st.error(f"Nie udaÅ‚o siÄ™ wykonaÄ‡ prognozy dla {selected_metal}. SprawdÅº logi w terminalu.")
            
    except Exception as e:
        st.error(f"BÅ‚Ä…d podczas prognozowania: {e}")

# Sekcje rozwijane z dodatkowymi informacjami
st.markdown("---")

# Informacje o ÅºrÃ³dÅ‚ach danych
with st.expander("Informacje o ÅºrÃ³dÅ‚ach danych"):
    st.markdown("""
    ### Å¹rÃ³dÅ‚a danych
    
    Dane historyczne cen metali szlachetnych i przemysÅ‚owych pochodzÄ… z wielu ÅºrÃ³deÅ‚:
    
    * **Yahoo Finance API** - gÅ‚Ã³wne ÅºrÃ³dÅ‚o dla zÅ‚ota, srebra, platyny i palladu
    * **London Metal Exchange** - dane dla miedzi
    * **World Bank** - dane makroekonomiczne
    * **FRED (Federal Reserve Economic Data)** - wskaÅºniki ekonomiczne i stopy procentowe
    
    Dane sÄ… automatycznie aktualizowane podczas uruchamiania aplikacji, jeÅ›li istniejÄ…ce dane sÄ… starsze niÅ¼ 24 godziny.
    """)

# Informacje o zastosowanych cechach autoregresyjnych (lag)
with st.expander("Informacje o cechach autoregresyjnych"):
    st.markdown("""
    ### Cechy autoregresyjne (lag features)
    
    Model wykorzystuje cechy autoregresyjne - wczeÅ›niejsze wartoÅ›ci cen jako cechy wejÅ›ciowe:
    
    * **Metal_lag_1** - cena z poprzedniego miesiÄ…ca
    * **Metal_lag_3** - cena sprzed trzech miesiÄ™cy
    
    Dodanie tych cech znaczÄ…co poprawia dokÅ‚adnoÅ›Ä‡ modelu w porÃ³wnaniu do uÅ¼ycia samych wskaÅºnikÃ³w makroekonomicznych.
    
    W prognozach rekurencyjnych (na wiele miesiÄ™cy do przodu), wartoÅ›ci lagÃ³w sÄ… aktualizowane na podstawie
    poprzednich prognoz, co poprawia jakoÅ›Ä‡ dÅ‚ugoterminowych przewidywaÅ„.
    """)

# Informacje o wskaÅºnikach makroekonomicznych
with st.expander("Informacje o wskaÅºnikach makroekonomicznych"):
    st.markdown("""
    ### WskaÅºniki makroekonomiczne
    
    Model uwzglÄ™dnia nastÄ™pujÄ…ce wskaÅºniki makroekonomiczne jako cechy wejÅ›ciowe:
    
    * **Indeks dolara amerykaÅ„skiego (DXY)** - wskaÅºnik wartoÅ›ci dolara wzglÄ™dem koszyka walut
    * **Inflacja w USA** - roczna stopa inflacji CPI
    * **Stopa procentowa Fed** - podstawowa stopa procentowa Fed
    * **Indeks VIX** - indeks zmiennoÅ›ci rynkÃ³w (tzw. "indeks strachu")
    * **Indeks S&P 500** - indeks 500 najwiÄ™kszych spÃ³Å‚ek notowanych na gieÅ‚dach w USA
    
    Dane te sÄ… znormalizowane przed podaniem do modelu.
    """)

# Informacje o algorytmach uczenia maszynowego
with st.expander("Informacje o algorytmach uczenia maszynowego"):
    st.markdown("""
    ### Algorytmy uczenia maszynowego
    
    Aplikacja wykorzystuje bibliotekÄ™ PyCaret do automatycznego trenowania i wyboru najlepszego modelu.
    Trenowanych jest wiele algorytmÃ³w, w tym:
    
    * **Linear Regression** - regresja liniowa
    * **Random Forest** - las losowy
    * **Gradient Boosting** - wzmacnianie gradientowe
    * **Decision Tree** - drzewa decyzyjne
    * **Support Vector Regression** - maszyna wektorÃ³w noÅ›nych
    * **Lasso Regression** - regresja Lasso
    * **Ridge Regression** - regresja Ridge
    * **Orthogonal Matching Pursuit** - algorytm OMP
    
    Najlepszy model jest wybierany na podstawie metryki MAPE (Mean Absolute Percentage Error).
    """)

# Informacje o uÅ¼ytkowaniu
with st.expander("Jak korzystaÄ‡ z aplikacji?"):
    st.markdown("""
    ### Jak korzystaÄ‡ z aplikacji?
    
    1. **Wybierz metal** w panelu bocznym (zÅ‚oto, srebro, platyna, pallad lub miedÅº)
    2. **Wybierz okres prognozy** za pomocÄ… suwaka (1-120 miesiÄ™cy)
    3. **Trenuj model** - kliknij przycisk "Trenuj model" aby wytrenowaÄ‡ nowy model dla wybranego metalu
    4. **Generuj prognozÄ™** - kliknij przycisk "Prognozuj cenÄ™" aby wygenerowaÄ‡ prognozÄ™ na wybrany okres
    5. **Analizuj wyniki** - przeglÄ…daj tabelÄ™ i wykres z prognozami oraz metryki jakoÅ›ci modelu
    
    > **Uwaga:** Dla kaÅ¼dego metalu naleÅ¼y osobno wytrenowaÄ‡ model przed prognozowaniem.
    """)